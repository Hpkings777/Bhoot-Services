<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Base64 Encoder/Decoder</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: #0f0f0f;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 10px;
    }

    .tabs {
      display: flex;
      margin: 20px 0;
      gap: 10px;
    }

    .tab {
      padding: 10px 20px;
      background: #222;
      border-radius: 5px;
      cursor: pointer;
      transition: 0.3s;
    }

    .tab.active {
      background: #00e676;
      color: #000;
      font-weight: bold;
    }

    .container {
      width: 100%;
      max-width: 600px;
    }

    .panel {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      position: relative;
    }

    .panel.active {
      display: flex;
    }

    textarea {
      width: 100%;
      height: 100px;
      border-radius: 6px;
      padding: 10px;
      font-size: 14px;
      resize: vertical;
      background: #333;
      color: #eee;
      border: 1px solid #555;
    }

    button {
      padding: 10px 20px;
      border: none;
      background: #00e676;
      color: #000;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
      transition: background 0.2s;
    }

    button:hover {
        background: #00c853;
    }

    input[type="file"] {
      display: none;
    }

    label.custom-file {
      background: #00e676;
      color: #000;
      font-weight: bold;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
      transition: background 0.2s;
    }

    label.custom-file:hover {
        background: #00c853;
    }

    img.preview {
      max-width: 100%;
      max-height: 300px;
      border-radius: 8px;
      object-fit: contain;
      border: 1px dashed #00e676;
      padding: 5px;
      background-color: #222;
    }

    .output {
      word-break: break-all;
    }

    .copy-btn, .paste-btn {
      position: absolute;
      bottom: 10px;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
      background: #00e676;
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
    }
    .copy-btn:hover, .paste-btn:hover {
        background: #00c853;
    }

    .copy-btn {
      right: 10px;
    }

    .paste-btn {
      left: 10px;
    }

    /* Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: #1e1e1e;
      padding: 25px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    .modal-content h2 {
        margin-bottom: 10px;
        color: #00e676;
        text-align: center;
    }

    .modal-preview-area {
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
        border: 2px solid #00e676;
        border-radius: 8px;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
    }

    #modalCanvas {
        display: block;
        max-width: 100%;
        height: auto;
    }

    .modal-options {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        margin-top: 15px;
        width: 100%;
    }

    .modal-options label {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 15px;
        color: #ddd;
        width: 100%;
        justify-content: center;
    }

    .modal-options input[type="range"] {
        flex-grow: 1;
        max-width: 200px;
        -webkit-appearance: none;
        height: 8px;
        background: #555;
        border-radius: 5px;
        outline: none;
        opacity: 0.7;
        transition: opacity .2s;
    }

    .modal-options input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #00e676;
        cursor: pointer;
    }

    .modal-options input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #00e676;
        cursor: pointer;
    }

    .modal-options span {
        min-width: 40px;
        text-align: right;
        color: #00e676;
        font-weight: bold;
    }

    .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
    }

    .modal-buttons button.cancel {
        background: #ff4d4d;
    }
    .modal-buttons button.cancel:hover {
        background: #cc0000;
    }

    /* Notification Styles */
    #notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 300px;
    }

    .notification {
      background: #333;
      color: #fff;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      opacity: 0; /* Start invisible */
      transform: translateX(100%); /* Start off-screen */
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      display: flex;
      align-items: center;
      gap: 10px;
      position: relative; /* For smooth removal */
      min-height: 40px; /* Prevent collapse during transition */
    }

    .notification.show {
      opacity: 1;
      transform: translateX(0);
    }

    /* Specific classes for animation control */
    .notification.enter {
        opacity: 0;
        transform: translateX(100%);
    }

    .notification.active {
        opacity: 1;
        transform: translateX(0);
    }

    .notification.exit {
        opacity: 0;
        transform: translateX(100%);
    }


    .notification.success {
      background: #28a745; /* Green */
    }

    .notification.error {
      background: #dc3545; /* Red */
    }

    .notification.info {
      background: #17a2b8; /* Blue */
    }

    .notification-icon {
      font-size: 1.2em; /* Adjust icon size */
    }

    /* New styles for quality dropdown */
    .quality-dropdown-container {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        justify-content: center;
    }
    .quality-dropdown-container label {
        margin-right: 5px;
    }
    .quality-dropdown-container select {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid #555;
        background: #333;
        color: #eee;
        font-size: 14px;
        appearance: none; /* Remove default arrow */
        background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23cccccc%22%20d%3D%22M287%2C114.1L146.2%2C254.9L5.4%2C114.1L5.4%2C114.1l140.8%2C140.8L287%2C114.1L287%2C114.1z%22%2F%3E%3C%2Fsvg%3E'); /* Custom arrow */
        background-repeat: no-repeat;
        background-position: right 8px center;
        background-size: 12px;
        cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>üß¨ Base64 Encoder / Decoder</h1>

  <div class="tabs">
    <div class="tab active" onclick="switchTab('text')">Text</div>
    <div class="tab" onclick="switchTab('image')">Image</div>
  </div>

  <div class="container">
    <div id="text" class="panel active">
      <textarea id="textInput" placeholder="Enter your text here..."></textarea>
      <div>
        <button onclick="encodeText()">Encode</button>
        <button onclick="decodeText()">Decode</button>
      </div>
      <div style="position: relative; width: 100%;">
        <textarea id="textOutput" readonly placeholder="Output will appear here..."></textarea>
        <button class="copy-btn" onclick="copyText('textOutput')">üìã Copy</button>
      </div>
    </div>

    <div id="image" class="panel">
      <label for="fileInput" class="custom-file">üìÅ Choose Image</label>
      <input type="file" id="fileInput" accept="image/*">
      <img id="imgPreview" class="preview" src="" style="display:none" />

      <div>
        <button onclick="encodeImageFromCurrentInput()">Encode (from current output)</button>
        <button onclick="decodeImageString()">Decode (to preview)</button>
      </div>
      <div style="position: relative; width: 100%;">
        <textarea id="imageOutput" class="output" placeholder="Base64 code will appear here..."></textarea>
        <button class="copy-btn" onclick="copyText('imageOutput')">üìã Copy</button>
        <button class="paste-btn" onclick="pasteImage()">üì• Paste</button>
      </div>
    </div>
  </div>

  <div id="imageModalOverlay" class="modal-overlay">
    <div class="modal-content">
      <h2>Image Settings</h2>
      <div class="modal-preview-area">
        <canvas id="modalCanvas"></canvas>
      </div>
      <div class="modal-options">
        <div class="quality-dropdown-container">
            <label for="imageQualityPreset">Image Quality:</label>
            <select id="imageQualityPreset" onchange="applyQualityPreset(); drawPreviewImage()">
                <option value="120">120p (Smallest)</option>
                <option value="240">240p</option>
                <option value="360">360p (Low)</option>
                <option value="480">480p (SD)</option>
                <option value="720" selected>720p (HD)</option>
                <option value="1080">1080p (Full HD)</option>
                <option value="1440">1440p (2K)</option>
                <option value="2160">2160p (4K)</option>
                <option value="original">Original Size</option>
            </select>
        </div>
        <label>
            Compression: <input type="range" id="modalCompressionRange" min="0.1" max="1.0" step="0.1" value="0.8" oninput="updateModalRangeValue('modalCompressionRange', 'modalCompressionValue', true); drawPreviewImage()"> <span id="modalCompressionValue">80%</span>
        </label>
      </div>
      <div class="modal-buttons">
        <button onclick="applyImageSettings()">Apply & Encode</button>
        <button class="cancel" onclick="closeImageModal()">Cancel</button>
      </div>
    </div>
  </div>

  <div id="notification-container"></div>

  <script>
    let originalImage = new Image();
    let modalCanvas = null;
    let modalCtx = null;
    let currentEncodedImage = ''; // Stores the final encoded Base64 for copying

    // Image quality presets map (max height/width for the given "p" quality)
    // For simplicity, these are max dimensions. A 720p image typically means 1280x720.
    // We'll scale the larger dimension to match, maintaining aspect ratio.
    const IMAGE_QUALITY_PRESETS = {
        '120': 120,
        '240': 240,
        '360': 360,
        '480': 480,
        '720': 720,
        '1080': 1080,
        '1440': 1440,
        '2160': 2160,
        'original': null // Special case for original size
    };

    document.addEventListener('DOMContentLoaded', () => {
        modalCanvas = document.getElementById('modalCanvas');
        modalCtx = modalCanvas.getContext('2d');
        // Initial setup for the compression range (quality preset handled by applyQualityPreset)
        updateModalRangeValue('modalCompressionRange', 'modalCompressionValue', true);
        applyQualityPreset(); // Apply default 720p preset on load
    });

    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
      document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
      document.getElementById(tabName).classList.add('active');

      if (tabName !== 'image') {
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
        document.getElementById('imageOutput').value = '';
        document.getElementById('fileInput').value = '';
        currentEncodedImage = '';
        closeImageModal();
      }
    }

    function encodeText() {
      const input = document.getElementById('textInput').value;
      if (!input.trim()) {
        showNotification('Please enter text to encode.', 'info');
        return;
      }
      try {
        const encoded = btoa(input);
        document.getElementById('textOutput').value = encoded;
        showNotification('Text encoded successfully!', 'success');
      } catch (e) {
        document.getElementById('textOutput').value = '';
        showNotification('Error encoding text: Input contains characters outside of the Latin1 range.', 'error');
        console.error("Text encoding error:", e);
      }
    }

    function decodeText() {
      const input = document.getElementById('textInput').value;
      if (!input.trim()) {
        showNotification('Please enter Base64 text to decode.', 'info');
        return;
      }
      try {
        const decoded = atob(input);
        document.getElementById('textOutput').value = decoded;
        showNotification('Text decoded successfully!', 'success');
      } catch (e) {
        document.getElementById('textOutput').value = '';
        showNotification('Invalid Base64 string for text decoding!', 'error');
        console.error("Text decoding error:", e);
      }
    }

    // --- Image Modal and Encoding Logic ---

    document.getElementById('fileInput').addEventListener('change', function() {
        const file = this.files[0];
        if (!file) {
            closeImageModal();
            return;
        }
        if (!file.type.startsWith('image/')) {
            showNotification('Please select a valid image file (e.g., JPEG, PNG, GIF).', 'error');
            this.value = '';
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            originalImage.onload = function() {
                openImageModal();
                // Reset to default preset on new image load, or keep current selection
                document.getElementById('imageQualityPreset').value = '720'; // Default to 720p
                document.getElementById('modalCompressionRange').value = 0.8; // Default compression
                applyQualityPreset(); // This will also call drawPreviewImage()
                updateModalRangeValue('modalCompressionRange', 'modalCompressionValue', true);
            };
            originalImage.onerror = function() {
                showNotification('Could not load image. It might be corrupted or an unsupported format.', 'error');
                closeImageModal();
                document.getElementById('fileInput').value = '';
            };
            originalImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });

    function openImageModal() {
        document.getElementById('imageModalOverlay').style.display = 'flex';
    }

    function closeImageModal() {
        document.getElementById('imageModalOverlay').style.display = 'none';
        originalImage.src = '';
        document.getElementById('fileInput').value = '';
        modalCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
    }

    // Applies the selected quality preset to the image sizing.
    function applyQualityPreset() {
        const presetValue = document.getElementById('imageQualityPreset').value;
        // The MAX_DIMENSION will be the value from the preset, or original if 'original'
        const MAX_DIMENSION_PRESET = IMAGE_QUALITY_PRESETS[presetValue];

        // This function doesn't directly set a slider, but tells drawPreviewImage how to scale
        drawPreviewImage(MAX_DIMENSION_PRESET);
    }


    function drawPreviewImage(forceMaxDimension = null) {
        if (!originalImage.src || !modalCanvas || !modalCtx) {
            return;
        }

        // Use the passed max dimension from preset, or recalculate if slider changed
        const currentSelectedPreset = document.getElementById('imageQualityPreset').value;
        let MAX_DIMENSION = forceMaxDimension !== null ? forceMaxDimension : IMAGE_QUALITY_PRESETS[currentSelectedPreset];

        // If 'original' is selected, use original image dimensions for encoding
        if (MAX_DIMENSION === null) {
            MAX_DIMENSION = Math.max(originalImage.width, originalImage.height); // Use the larger dimension
        }


        let width = originalImage.width;
        let height = originalImage.height;

        // Scale based on the MAX_DIMENSION (either from preset or manually calculated)
        if (MAX_DIMENSION && (width > MAX_DIMENSION || height > MAX_DIMENSION)) {
            if (width > height) {
                height *= MAX_DIMENSION / width;
                width = MAX_DIMENSION;
            } else {
                width *= MAX_DIMENSION / height;
                height = MAX_DIMENSION;
            }
        }

        // Ensure modal preview itself doesn't exceed its visual bounds, independent of encoding size
        const MAX_MODAL_DISPLAY_WIDTH = 500;
        const MAX_MODAL_DISPLAY_HEIGHT = 400;
        let displayWidth = width;
        let displayHeight = height;

        if (displayWidth > MAX_MODAL_DISPLAY_WIDTH) {
            displayHeight *= MAX_MODAL_DISPLAY_WIDTH / displayWidth;
            displayWidth = MAX_MODAL_DISPLAY_WIDTH;
        }
        if (displayHeight > MAX_MODAL_DISPLAY_HEIGHT) {
            displayWidth *= MAX_MODAL_DISPLAY_HEIGHT / displayHeight;
            displayHeight = MAX_MODAL_DISPLAY_HEIGHT;
        }

        modalCanvas.width = displayWidth;
        modalCanvas.height = displayHeight;

        modalCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
        modalCtx.drawImage(originalImage, 0, 0, displayWidth, displayHeight);
    }

    function applyImageSettings() {
        if (!originalImage.src) {
            showNotification('No image selected for processing.', 'error');
            closeImageModal();
            return;
        }

        const selectedPreset = document.getElementById('imageQualityPreset').value;
        let MAX_DIMENSION_FINAL = IMAGE_QUALITY_PRESETS[selectedPreset];

        // If 'original' is selected, use actual image dimensions
        if (MAX_DIMENSION_FINAL === null) {
            MAX_DIMENSION_FINAL = Math.max(originalImage.width, originalImage.height);
        }

        const COMPRESSION_QUALITY_FINAL = parseFloat(document.getElementById('modalCompressionRange').value);

        let finalWidth = originalImage.width;
        let finalHeight = originalImage.height;

        // Scale based on the chosen preset
        if (MAX_DIMENSION_FINAL && (finalWidth > MAX_DIMENSION_FINAL || finalHeight > MAX_DIMENSION_FINAL)) {
            if (finalWidth > finalHeight) {
                finalHeight *= MAX_DIMENSION_FINAL / finalWidth;
                finalWidth = MAX_DIMENSION_FINAL;
            } else {
                finalWidth *= MAX_DIMENSION_FINAL / finalHeight;
                finalHeight = MAX_DIMENSION_FINAL;
            }
        }

        // Create a temporary canvas for the final encoding
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = finalWidth;
        tempCanvas.height = finalHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(originalImage, 0, 0, finalWidth, finalHeight);

        const base64String = tempCanvas.toDataURL('image/jpeg', COMPRESSION_QUALITY_FINAL);

        currentEncodedImage = base64String;
        document.getElementById('imageOutput').value = base64String;
        document.getElementById('imgPreview').src = base64String;
        document.getElementById('imgPreview').style.display = 'block';

        closeImageModal();
        showNotification('Image encoded successfully!', 'success');
    }

    function encodeImageFromCurrentInput() {
        const outputString = document.getElementById('imageOutput').value;
        if (outputString && outputString.startsWith("data:image")) {
            showNotification('Image is already encoded. Use "Choose Image" to re-encode with new settings.', 'info');
        } else if (document.getElementById('fileInput').files.length > 0) {
            showNotification('Please use "Apply & Encode" in the Image Settings dialog to process the chosen image.', 'info');
        } else {
            showNotification('No image selected or Base64 string to encode. Choose an image first.', 'info');
        }
    }

    function decodeImageString() {
      const base64String = document.getElementById('imageOutput').value.trim();
      if (!base64String) {
        showNotification('Please paste a Base64 image string into the text area to decode.', 'info');
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
        return;
      }

      // Stricter validation for image Base64 string format
      if (!base64String.startsWith("data:image/") || base64String.indexOf(';base64,') === -1) {
        showNotification("Invalid Base64 image string. It should start with 'data:image/...' and contain ';base64,'.", 'error');
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
        return;
      }

      const img = new Image();
      img.onload = function() {
        document.getElementById('imgPreview').src = base64String;
        document.getElementById('imgPreview').style.display = 'block';
        showNotification('Image decoded and displayed in preview.', 'success');
      };
      img.onerror = function() {
        showNotification('Failed to decode Base64 string to image. It might be corrupted or malformed. Ensure the data part is correct.', 'error');
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
      };
      img.src = base64String; // Attempt to load the image
    }

    function pasteImage() {
      navigator.clipboard.readText().then(text => {
        text = text.trim();
        if (!text) {
          showNotification('Clipboard is empty or contains only whitespace.', 'info');
          return;
        }

        document.getElementById('imageOutput').value = text;
        currentEncodedImage = text;

        if (text.startsWith("data:image/") && text.indexOf(';base64,') !== -1) {
          const img = new Image();
          img.onload = function() {
              document.getElementById('imgPreview').src = text;
              document.getElementById('imgPreview').style.display = 'block';
              showNotification('Pasted Base64 image displayed in preview.', 'success');
          };
          img.onerror = function() {
              showNotification('Pasted content looks like Base64 but failed to load as an image (corrupted?).', 'error');
              document.getElementById('imgPreview').style.display = 'none';
              document.getElementById('imgPreview').src = '';
          };
          img.src = text;
        } else {
          showNotification("Pasted content is not a valid image Base64 string. Ensure it starts with 'data:image/' and contains ';base64,'.", 'error');
          document.getElementById('imgPreview').style.display = 'none';
          document.getElementById('imgPreview').src = '';
        }
      }).catch(err => {
        showNotification("Clipboard access denied. Please grant permission to read clipboard.", 'error');
        console.error("Clipboard paste error:", err);
      });
    }

    function copyText(id) {
      const textArea = document.getElementById(id);
      const textToCopy = (id === 'imageOutput' && currentEncodedImage) ? currentEncodedImage : textArea.value;

      if (!textToCopy.trim()) {
        showNotification('Nothing to copy!', 'info');
        return;
      }

      navigator.clipboard.writeText(textToCopy)
        .then(() => {
          showNotification('Copied to clipboard!', 'success');
        })
        .catch(err => {
          textArea.select();
          document.execCommand("copy");
          showNotification('Copied to clipboard (fallback)!', 'info');
          console.warn("Clipboard writeText failed, used fallback:", err);
        });
    }

    function updateModalRangeValue(rangeId, valueId, isPercentage = false) {
        const range = document.getElementById(rangeId);
        const valueSpan = document.getElementById(valueId);
        if (isPercentage) {
            valueSpan.textContent = Math.round(parseFloat(range.value) * 100) + '%';
        } else {
            // This function is now only for the compression slider, so it's always percentage
            // The MAX_WIDTH will be driven by the select dropdown
            valueSpan.textContent = range.value + 'px'; // Keeping for robustness if you add other ranges
        }
    }

    // --- Custom Notification System (More Robust) ---
    // Use an array to manage multiple notifications or a single, managed instance
    const notificationQueue = [];
    let isShowingNotification = false;

    function showNotification(message, type = 'info', duration = 3000) {
        const container = document.getElementById('notification-container');

        // Create a new notification element for each call
        const notificationElement = document.createElement('div');
        notificationElement.className = 'notification enter'; // Start with enter class for animation

        const iconSpan = document.createElement('span');
        iconSpan.className = 'notification-icon';
        const messageSpan = document.createElement('span');
        messageSpan.className = 'notification-message';

        notificationElement.appendChild(iconSpan);
        notificationElement.appendChild(messageSpan);
        container.appendChild(notificationElement);

        notificationQueue.push({ element: notificationElement, message, type, duration });

        processNotificationQueue();
    }

    function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) {
            return; // Already showing or nothing to show
        }

        isShowingNotification = true;
        const currentNotification = notificationQueue.shift(); // Get the next notification from the queue

        const { element, message, type, duration } = currentNotification;

        element.classList.add(type);
        element.querySelector('.notification-message').textContent = message;

        const iconSpan = element.querySelector('.notification-icon');
        switch (type) {
            case 'success':
                iconSpan.textContent = '‚úîÔ∏è';
                break;
            case 'error':
                iconSpan.textContent = '‚ùå';
                break;
            case 'info':
                iconSpan.textContent = '‚ÑπÔ∏è';
                break;
            default:
                iconSpan.textContent = '';
        }

        // Trigger 'active' class after a short delay to ensure 'enter' transition starts
        setTimeout(() => {
            element.classList.remove('enter');
            element.classList.add('active'); // Start the main 'show' animation
        }, 50); // Small delay to ensure CSS transition gets applied

        // Set timeout to hide the notification
        setTimeout(() => {
            element.classList.remove('active');
            element.classList.add('exit'); // Start the 'hide' animation

            // Remove element after transition completes
            element.addEventListener('transitionend', function handler() {
                // Ensure it's the 'exit' transition ending before removal
                if (element.classList.contains('exit')) {
                    element.remove();
                    element.removeEventListener('transitionend', handler);
                    isShowingNotification = false; // Allow next notification to show
                    processNotificationQueue(); // Process next in queue
                }
            });
        }, duration);
    }
  </script>
</body>
</html>
