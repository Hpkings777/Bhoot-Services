<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Base64 Encoder/Decoder</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: #0f0f0f;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 10px;
    }

    .tabs {
      display: flex;
      margin: 20px 0;
      gap: 10px;
    }

    .tab {
      padding: 10px 20px;
      background: #222;
      border-radius: 5px;
      cursor: pointer;
      transition: 0.3s;
    }

    .tab.active {
      background: #00e676;
      color: #000;
      font-weight: bold;
    }

    .container {
      width: 100%;
      max-width: 600px;
    }

    .panel {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      position: relative;
    }

    .panel.active {
      display: flex;
    }

    textarea {
      width: 100%;
      height: 100px;
      border-radius: 6px;
      padding: 10px;
      font-size: 14px;
      resize: vertical;
      background: #333;
      color: #eee;
      border: 1px solid #555;
    }

    button {
      padding: 10px 20px;
      border: none;
      background: #00e676;
      color: #000;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
      transition: background 0.2s;
    }

    button:hover {
        background: #00c853;
    }

    input[type="file"] {
      display: none;
    }

    label.custom-file {
      background: #00e676;
      color: #000;
      font-weight: bold;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
      transition: background 0.2s;
    }

    label.custom-file:hover {
        background: #00c853;
    }

    img.preview {
      max-width: 100%;
      max-height: 300px;
      border-radius: 8px;
      object-fit: contain;
      border: 1px dashed #00e676;
      padding: 5px;
      background-color: #222;
    }

    .output {
      word-break: break-all;
    }

    .copy-btn, .paste-btn {
      position: absolute;
      bottom: 10px;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
      background: #00e676;
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
    }
    .copy-btn:hover, .paste-btn:hover {
        background: #00c853;
    }

    .copy-btn {
      right: 10px;
    }

    .paste-btn {
      left: 10px;
    }

    /* Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: #1e1e1e;
      padding: 25px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    .modal-content h2 {
        margin-bottom: 10px;
        color: #00e676;
        text-align: center;
    }

    .modal-preview-area {
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
        border: 2px solid #00e676;
        border-radius: 8px;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
    }

    #modalCanvas {
        display: block;
        max-width: 100%;
        height: auto;
    }

    .modal-options {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        margin-top: 15px;
        width: 100%;
    }

    .modal-options label {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 15px;
        color: #ddd;
        width: 100%;
        justify-content: center;
    }

    .modal-options input[type="range"] {
        flex-grow: 1;
        max-width: 200px;
        -webkit-appearance: none;
        height: 8px;
        background: #555;
        border-radius: 5px;
        outline: none;
        opacity: 0.7;
        transition: opacity .2s;
    }

    .modal-options input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #00e676;
        cursor: pointer;
    }

    .modal-options input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #00e676;
        cursor: pointer;
    }

    .modal-options span {
        min-width: 40px;
        text-align: right;
        color: #00e676;
        font-weight: bold;
    }

    .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
    }

    .modal-buttons button.cancel {
        background: #ff4d4d;
    }
    .modal-buttons button.cancel:hover {
        background: #cc0000;
    }

    /* Notification Styles */
    #notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 300px;
    }

    .notification {
      background: #333;
      color: #fff;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      opacity: 0; /* Start invisible */
      transform: translateX(100%); /* Start off-screen */
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .notification.show {
      opacity: 1;
      transform: translateX(0);
    }

    .notification.hide {
      opacity: 0;
      transform: translateX(100%);
    }

    .notification.success {
      background: #28a745; /* Green */
    }

    .notification.error {
      background: #dc3545; /* Red */
    }

    .notification.info {
      background: #17a2b8; /* Blue */
    }

    .notification-icon {
      font-size: 1.2em; /* Adjust icon size */
    }
  </style>
</head>
<body>
  <h1>üß¨ Base64 Encoder / Decoder</h1>

  <div class="tabs">
    <div class="tab active" onclick="switchTab('text')">Text</div>
    <div class="tab" onclick="switchTab('image')">Image</div>
  </div>

  <div class="container">
    <div id="text" class="panel active">
      <textarea id="textInput" placeholder="Enter your text here..."></textarea>
      <div>
        <button onclick="encodeText()">Encode</button>
        <button onclick="decodeText()">Decode</button>
      </div>
      <div style="position: relative; width: 100%;">
        <textarea id="textOutput" readonly placeholder="Output will appear here..."></textarea>
        <button class="copy-btn" onclick="copyText('textOutput')">üìã Copy</button>
      </div>
    </div>

    <div id="image" class="panel">
      <label for="fileInput" class="custom-file">üìÅ Choose Image</label>
      <input type="file" id="fileInput" accept="image/*">
      <img id="imgPreview" class="preview" src="" style="display:none" />

      <div>
        <button onclick="encodeImageFromCurrentInput()">Encode (from current output)</button>
        <button onclick="decodeImageString()">Decode (to preview)</button>
      </div>
      <div style="position: relative; width: 100%;">
        <textarea id="imageOutput" class="output" placeholder="Base64 code will appear here..."></textarea>
        <button class="copy-btn" onclick="copyText('imageOutput')">üìã Copy</button>
        <button class="paste-btn" onclick="pasteImage()">üì• Paste</button>
      </div>
    </div>
  </div>

  <div id="imageModalOverlay" class="modal-overlay">
    <div class="modal-content">
      <h2>Image Settings</h2>
      <div class="modal-preview-area">
        <canvas id="modalCanvas"></canvas>
      </div>
      <div class="modal-options">
        <label>
            Max Width: <input type="range" id="modalMaxWidthRange" min="100" max="1920" value="800" oninput="updateModalRangeValue('modalMaxWidthRange', 'modalMaxWidthValue'); drawPreviewImage()"> <span id="modalMaxWidthValue">800px</span>
        </label>
        <label>
            Quality: <input type="range" id="modalQualityRange" min="0.1" max="1.0" step="0.1" value="0.8" oninput="updateModalRangeValue('modalQualityRange', 'modalQualityValue', true); drawPreviewImage()"> <span id="modalQualityValue">80%</span>
        </label>
      </div>
      <div class="modal-buttons">
        <button onclick="applyImageSettings()">Apply & Encode</button>
        <button class="cancel" onclick="closeImageModal()">Cancel</button>
      </div>
    </div>
  </div>

  <div id="notification-container"></div>

  <script>
    // Global variables to store the original image data for modal use
    let originalImage = new Image();
    let modalCanvas = null;
    let modalCtx = null;
    let currentEncodedImage = ''; // Stores the final encoded Base64 for copying

    document.addEventListener('DOMContentLoaded', () => {
        modalCanvas = document.getElementById('modalCanvas');
        modalCtx = modalCanvas.getContext('2d');
        updateModalRangeValue('modalMaxWidthRange', 'modalMaxWidthValue');
        updateModalRangeValue('modalQualityRange', 'modalQualityValue', true);
    });

    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
      document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
      document.getElementById(tabName).classList.add('active');

      // Clear image related fields when switching away from image tab
      if (tabName !== 'image') {
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
        document.getElementById('imageOutput').value = '';
        document.getElementById('fileInput').value = ''; // Clear file input
        currentEncodedImage = ''; // Clear stored base64
        closeImageModal(); // Close modal if open
      }
    }

    function encodeText() {
      const input = document.getElementById('textInput').value;
      if (!input.trim()) {
        showNotification('Please enter text to encode.', 'info');
        return;
      }
      try {
        const encoded = btoa(input);
        document.getElementById('textOutput').value = encoded;
        showNotification('Text encoded successfully!', 'success');
      } catch (e) {
        document.getElementById('textOutput').value = '';
        showNotification('Error encoding text: Input contains characters outside of the Latin1 range.', 'error');
        console.error("Text encoding error:", e);
      }
    }

    function decodeText() {
      const input = document.getElementById('textInput').value;
      if (!input.trim()) {
        showNotification('Please enter Base64 text to decode.', 'info');
        return;
      }
      try {
        const decoded = atob(input);
        document.getElementById('textOutput').value = decoded;
        showNotification('Text decoded successfully!', 'success');
      } catch (e) {
        document.getElementById('textOutput').value = '';
        showNotification('Invalid Base64 string for text decoding!', 'error');
        console.error("Text decoding error:", e);
      }
    }

    // --- Image Modal and Encoding Logic ---

    // Listener for file input change
    document.getElementById('fileInput').addEventListener('change', function() {
        const file = this.files[0];
        if (!file) {
            closeImageModal(); // If user cancels file selection
            return;
        }
        if (!file.type.startsWith('image/')) {
            showNotification('Please select a valid image file.', 'error');
            this.value = ''; // Clear the file input
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            originalImage.onload = function() {
                openImageModal();
                // Set initial values for modal sliders (could be remembered from last session or default)
                document.getElementById('modalMaxWidthRange').value = 800; // Default max width
                document.getElementById('modalQualityRange').value = 0.8;   // Default quality
                updateModalRangeValue('modalMaxWidthRange', 'modalMaxWidthValue');
                updateModalRangeValue('modalQualityRange', 'modalQualityValue', true);
                drawPreviewImage(); // Draw initial preview
            };
            originalImage.onerror = function() {
                showNotification('Could not load image. It might be corrupted.', 'error');
                closeImageModal();
                document.getElementById('fileInput').value = '';
            };
            originalImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });

    function openImageModal() {
        document.getElementById('imageModalOverlay').style.display = 'flex';
    }

    function closeImageModal() {
        document.getElementById('imageModalOverlay').style.display = 'none';
        // Clear original image source and file input to reset
        originalImage.src = '';
        document.getElementById('fileInput').value = '';
        modalCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height); // Clear canvas
    }

    function drawPreviewImage() {
        if (!originalImage.src || !modalCanvas || !modalCtx) {
            return;
        }

        const MAX_WIDTH = parseInt(document.getElementById('modalMaxWidthRange').value, 10);
        const QUALITY = parseFloat(document.getElementById('modalQualityRange').value); // Though not used for drawing, good to keep context

        let width = originalImage.width;
        let height = originalImage.height;

        // Calculate new dimensions while maintaining aspect ratio for modal display
        // Limit max width in modal and also max height to fit screen
        const MAX_MODAL_DISPLAY_WIDTH = 500;
        const MAX_MODAL_DISPLAY_HEIGHT = 400; // Visual height limit for preview

        // Scale based on selected max width
        if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
        }
        // Then scale again if new height exceeds modal display limit
        if (height > MAX_MODAL_DISPLAY_HEIGHT) {
            width *= MAX_MODAL_DISPLAY_HEIGHT / height;
            height = MAX_MODAL_DISPLAY_HEIGHT;
        }
        // Finally, scale again if new width exceeds modal display limit (can happen after height scale)
        if (width > MAX_MODAL_DISPLAY_WIDTH) {
            height *= MAX_MODAL_DISPLAY_WIDTH / width;
            width = MAX_MODAL_DISPLAY_WIDTH;
        }


        // Set canvas dimensions
        modalCanvas.width = width;
        modalCanvas.height = height;

        // Clear canvas and draw image
        modalCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
        modalCtx.drawImage(originalImage, 0, 0, width, height);
    }

    function applyImageSettings() {
        if (!originalImage.src) { // Check originalImage.src rather than canvas
            showNotification('No image selected or loaded for processing.', 'error');
            closeImageModal();
            return;
        }

        const MAX_WIDTH_FINAL = parseInt(document.getElementById('modalMaxWidthRange').value, 10);
        const QUALITY_FINAL = parseFloat(document.getElementById('modalQualityRange').value);

        let finalWidth = originalImage.width;
        let finalHeight = originalImage.height;

        // Calculate final dimensions for encoding (can be larger than modal preview)
        const ABSOLUTE_MAX_HEIGHT_ENCODE = 2000; // Prevent extremely tall outputs

        if (finalWidth > MAX_WIDTH_FINAL) {
            finalHeight *= MAX_WIDTH_FINAL / finalWidth;
            finalWidth = MAX_WIDTH_FINAL;
        }
        if (finalHeight > ABSOLUTE_MAX_HEIGHT_ENCODE) {
            finalWidth *= ABSOLUTE_MAX_HEIGHT_ENCODE / finalHeight;
            finalHeight = ABSOLUTE_MAX_HEIGHT_ENCODE;
        }

        // Create a temporary canvas for the final encoding
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = finalWidth;
        tempCanvas.height = finalHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(originalImage, 0, 0, finalWidth, finalHeight);

        const base64String = tempCanvas.toDataURL('image/jpeg', QUALITY_FINAL);

        currentEncodedImage = base64String;
        document.getElementById('imageOutput').value = base64String;
        document.getElementById('imgPreview').src = base64String;
        document.getElementById('imgPreview').style.display = 'block';

        closeImageModal();
        showNotification('Image encoded successfully!', 'success');
    }

    // This button now encodes the content *already present* in the imageOutput textarea
    // or provides guidance if no image is ready.
    function encodeImageFromCurrentInput() {
        const outputString = document.getElementById('imageOutput').value;
        if (outputString && outputString.startsWith("data:image")) {
            showNotification('Image is already encoded. Use "Choose Image" to re-encode with new settings.', 'info');
        } else if (document.getElementById('fileInput').files.length > 0) {
            // If a file is chosen but modal not applied yet
            showNotification('Please use "Apply & Encode" in the Image Settings dialog to process the chosen image.', 'info');
        }
        else {
            showNotification('No image selected or Base64 string to encode. Choose an image first.', 'info');
        }
    }

    function decodeImageString() {
      const base64String = document.getElementById('imageOutput').value.trim();
      if (!base64String) {
        showNotification('Please paste a Base64 image string into the text area to decode.', 'info');
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
        return;
      }

      // Stricter validation for image Base64 string
      if (!base64String.startsWith("data:image/") || base64String.indexOf(';base64,') === -1) {
        showNotification("Invalid Base64 image string. It should start with 'data:image/...' and contain ';base64,'.", 'error');
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
        return;
      }

      const img = new Image();
      img.onload = function() {
        document.getElementById('imgPreview').src = base64String;
        document.getElementById('imgPreview').style.display = 'block';
        showNotification('Image decoded and displayed in preview.', 'success');
      };
      img.onerror = function() {
        showNotification('Failed to decode Base64 string to image. It might be corrupted or malformed.', 'error');
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
      };
      img.src = base64String; // Attempt to load the image
    }

    function pasteImage() {
      navigator.clipboard.readText().then(text => {
        text = text.trim(); // Trim whitespace
        if (!text) {
          showNotification('Clipboard is empty or contains only whitespace.', 'info');
          return;
        }

        document.getElementById('imageOutput').value = text;
        currentEncodedImage = text; // Store for potential copy/decode

        if (text.startsWith("data:image/") && text.indexOf(';base64,') !== -1) {
          // Attempt to display immediately, but also confirm it's valid via image object
          const img = new Image();
          img.onload = function() {
              document.getElementById('imgPreview').src = text;
              document.getElementById('imgPreview').style.display = 'block';
              showNotification('Pasted Base64 image displayed in preview.', 'success');
          };
          img.onerror = function() {
              showNotification('Pasted content looks like Base64 but failed to load as an image.', 'error');
              document.getElementById('imgPreview').style.display = 'none';
              document.getElementById('imgPreview').src = '';
          };
          img.src = text;
        } else {
          showNotification("Pasted content is not a valid image Base64 string. Ensure it starts with 'data:image/' and contains ';base64,'.", 'error');
          document.getElementById('imgPreview').style.display = 'none';
          document.getElementById('imgPreview').src = '';
        }
      }).catch(err => {
        showNotification("Clipboard access denied. Please grant permission.", 'error');
        console.error("Clipboard paste error:", err);
      });
    }

    function copyText(id) {
      const textArea = document.getElementById(id);
      const textToCopy = (id === 'imageOutput' && currentEncodedImage) ? currentEncodedImage : textArea.value;

      if (!textToCopy.trim()) {
        showNotification('Nothing to copy!', 'info');
        return;
      }

      navigator.clipboard.writeText(textToCopy)
        .then(() => {
          showNotification('Copied to clipboard!', 'success');
        })
        .catch(err => {
          // Fallback for older browsers or if permission is denied
          textArea.select();
          document.execCommand("copy");
          showNotification('Copied to clipboard (fallback)!', 'info');
          console.warn("Clipboard writeText failed, used fallback:", err);
        });
    }

    function updateModalRangeValue(rangeId, valueId, isPercentage = false) {
        const range = document.getElementById(rangeId);
        const valueSpan = document.getElementById(valueId);
        if (isPercentage) {
            valueSpan.textContent = Math.round(parseFloat(range.value) * 100) + '%';
        } else {
            valueSpan.textContent = range.value + 'px';
        }
    }

    // --- Custom Notification System ---
    let notificationTimeout;

    function showNotification(message, type = 'info', duration = 3000) {
        const container = document.getElementById('notification-container');
        let notificationElement = document.querySelector('.notification');

        // If no notification element exists, create one
        if (!notificationElement) {
            notificationElement = document.createElement('div');
            notificationElement.className = 'notification';
            // Optional: add an icon based on type
            const iconSpan = document.createElement('span');
            iconSpan.className = 'notification-icon';
            notificationElement.appendChild(iconSpan);
            const messageSpan = document.createElement('span');
            messageSpan.className = 'notification-message';
            notificationElement.appendChild(messageSpan);
            container.appendChild(notificationElement);
        }

        // Clear previous classes and set new ones
        notificationElement.className = 'notification'; // Reset classes
        notificationElement.classList.add(type);
        notificationElement.querySelector('.notification-message').textContent = message;

        // Set icon
        const iconSpan = notificationElement.querySelector('.notification-icon');
        switch (type) {
            case 'success':
                iconSpan.textContent = '‚úîÔ∏è'; // Unicode checkmark
                break;
            case 'error':
                iconSpan.textContent = '‚ùå'; // Unicode X mark
                break;
            case 'info':
                iconSpan.textContent = '‚ÑπÔ∏è'; // Unicode info icon
                break;
            default:
                iconSpan.textContent = '';
        }

        // Trigger show animation
        // Use a small timeout to ensure the browser registers the class removal before adding 'show'
        // This makes the transition re-run if a new notification comes quickly.
        setTimeout(() => {
            notificationElement.classList.add('show');
        }, 10);


        // Clear any existing hide timeout
        if (notificationTimeout) {
            clearTimeout(notificationTimeout);
        }

        // Set timeout to hide the notification
        notificationTimeout = setTimeout(() => {
            notificationElement.classList.remove('show');
            notificationElement.classList.add('hide'); // Add hide class for exit animation
            // Remove element after transition completes
            notificationElement.addEventListener('transitionend', function handler() {
                if (!notificationElement.classList.contains('show')) { // Only remove if actually hidden
                    notificationElement.remove();
                    notificationElement.removeEventListener('transitionend', handler);
                }
            });
        }, duration);
    }
  </script>
</body>
</html>
