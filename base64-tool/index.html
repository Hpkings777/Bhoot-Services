<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Base64 Encoder/Decoder</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: #0f0f0f;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 10px;
    }

    .tabs {
      display: flex;
      margin: 20px 0;
      gap: 10px;
    }

    .tab {
      padding: 10px 20px;
      background: #222;
      border-radius: 5px;
      cursor: pointer;
      transition: 0.3s;
    }

    .tab.active {
      background: #00e676;
      color: #000;
      font-weight: bold;
    }

    .container {
      width: 100%;
      max-width: 600px;
    }

    .panel {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      position: relative;
    }

    .panel.active {
      display: flex;
    }

    textarea {
      width: 100%;
      height: 100px;
      border-radius: 6px;
      padding: 10px;
      font-size: 14px;
      resize: vertical;
      background: #333;
      color: #eee;
      border: 1px solid #555;
    }

    button {
      padding: 10px 20px;
      border: none;
      background: #00e676;
      color: #000;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
      transition: background 0.2s;
    }

    button:hover {
        background: #00c853;
    }

    input[type="file"] {
      display: none;
    }

    label.custom-file {
      background: #00e676;
      color: #000;
      font-weight: bold;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
      transition: background 0.2s;
    }

    label.custom-file:hover {
        background: #00c853;
    }

    img.preview {
      max-width: 100%;
      max-height: 300px;
      border-radius: 8px;
      object-fit: contain;
      border: 1px dashed #00e676;
      padding: 5px;
      background-color: #222;
    }

    .output {
      word-break: break-all;
    }

    .copy-btn, .paste-btn {
      position: absolute;
      bottom: 10px;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
      background: #00e676;
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
    }
    .copy-btn:hover, .paste-btn:hover {
        background: #00c853;
    }

    .copy-btn {
      right: 10px;
    }

    .paste-btn {
      left: 10px;
    }

    /* Modal Styles */
    .modal-overlay {
      display: none; /* Hidden by default */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: #1e1e1e;
      padding: 25px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    .modal-content h2 {
        margin-bottom: 10px;
        color: #00e676;
        text-align: center;
    }

    .modal-preview-area {
        width: 100%;
        max-width: 500px; /* Limit modal image width */
        margin: 0 auto;
        border: 2px solid #00e676;
        border-radius: 8px;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden; /* Important to contain the canvas */
    }

    #modalCanvas {
        display: block; /* Remove extra space below canvas */
        max-width: 100%;
        height: auto;
    }

    .modal-options {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        margin-top: 15px;
        width: 100%;
    }

    .modal-options label {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 15px;
        color: #ddd;
        width: 100%;
        justify-content: center;
    }

    .modal-options input[type="range"] {
        flex-grow: 1; /* Make slider take available space */
        max-width: 200px;
        -webkit-appearance: none;
        height: 8px;
        background: #555;
        border-radius: 5px;
        outline: none;
        opacity: 0.7;
        transition: opacity .2s;
    }

    .modal-options input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #00e676;
        cursor: pointer;
    }

    .modal-options input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #00e676;
        cursor: pointer;
    }

    .modal-options span {
        min-width: 40px;
        text-align: right;
        color: #00e676;
        font-weight: bold;
    }

    .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
    }

    .modal-buttons button.cancel {
        background: #ff4d4d;
    }
    .modal-buttons button.cancel:hover {
        background: #cc0000;
    }
  </style>
</head>
<body>
  <h1>üß¨ Base64 Encoder / Decoder</h1>

  <div class="tabs">
    <div class="tab active" onclick="switchTab('text')">Text</div>
    <div class="tab" onclick="switchTab('image')">Image</div>
  </div>

  <div class="container">
    <div id="text" class="panel active">
      <textarea id="textInput" placeholder="Enter your text here..."></textarea>
      <div>
        <button onclick="encodeText()">Encode</button>
        <button onclick="decodeText()">Decode</button>
      </div>
      <div style="position: relative; width: 100%;">
        <textarea id="textOutput" readonly placeholder="Output will appear here..."></textarea>
        <button class="copy-btn" onclick="copyText('textOutput')">üìã Copy</button>
      </div>
    </div>

    <div id="image" class="panel">
      <label for="fileInput" class="custom-file">üìÅ Choose Image</label>
      <input type="file" id="fileInput" accept="image/*">
      <img id="imgPreview" class="preview" src="" style="display:none" />

      <div>
        <button onclick="encodeImageFromCurrentInput()">Encode</button>
        <button onclick="decodeImageString()">Decode</button>
      </div>
      <div style="position: relative; width: 100%;">
        <textarea id="imageOutput" class="output" placeholder="Base64 code will appear here..."></textarea>
        <button class="copy-btn" onclick="copyText('imageOutput')">üìã Copy</button>
        <button class="paste-btn" onclick="pasteImage()">üì• Paste</button>
      </div>
    </div>
  </div>

  <div id="imageModalOverlay" class="modal-overlay">
    <div class="modal-content">
      <h2>Image Settings</h2>
      <div class="modal-preview-area">
        <canvas id="modalCanvas"></canvas>
      </div>
      <div class="modal-options">
        <label>
            Max Width: <input type="range" id="modalMaxWidthRange" min="100" max="1920" value="800" oninput="updateModalRangeValue('modalMaxWidthRange', 'modalMaxWidthValue'); drawPreviewImage()"> <span id="modalMaxWidthValue">800px</span>
        </label>
        <label>
            Quality: <input type="range" id="modalQualityRange" min="0.1" max="1.0" step="0.1" value="0.8" oninput="updateModalRangeValue('modalQualityRange', 'modalQualityValue', true); drawPreviewImage()"> <span id="modalQualityValue">80%</span>
        </label>
      </div>
      <div class="modal-buttons">
        <button onclick="applyImageSettings()">Apply & Encode</button>
        <button class="cancel" onclick="closeImageModal()">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    // Global variables to store the original image data for modal use
    let originalImage = new Image();
    let modalCanvas = null;
    let modalCtx = null;
    let currentEncodedImage = ''; // Stores the final encoded Base64 for copying

    document.addEventListener('DOMContentLoaded', () => {
        modalCanvas = document.getElementById('modalCanvas');
        modalCtx = modalCanvas.getContext('2d');
        updateModalRangeValue('modalMaxWidthRange', 'modalMaxWidthValue');
        updateModalRangeValue('modalQualityRange', 'modalQualityValue', true);
    });

    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
      document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
      document.getElementById(tabName).classList.add('active');

      // Clear image related fields when switching away from image tab
      if (tabName !== 'image') {
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
        document.getElementById('imageOutput').value = '';
        document.getElementById('fileInput').value = ''; // Clear file input
        currentEncodedImage = ''; // Clear stored base64
        closeImageModal(); // Close modal if open
      }
    }

    function encodeText() {
      const input = document.getElementById('textInput').value;
      try {
        const encoded = btoa(input);
        document.getElementById('textOutput').value = encoded;
      } catch (e) {
        document.getElementById('textOutput').value = 'Error encoding text: ' + e.message;
      }
    }

    function decodeText() {
      const input = document.getElementById('textInput').value;
      try {
        const decoded = atob(input);
        document.getElementById('textOutput').value = decoded;
      } catch (e) {
        document.getElementById('textOutput').value = 'Invalid Base64 string!';
      }
    }

    // --- Image Modal and Encoding Logic ---

    // Listener for file input change
    document.getElementById('fileInput').addEventListener('change', function() {
        const file = this.files[0];
        if (!file) {
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            originalImage.onload = function() {
                openImageModal();
                // Set initial values for modal sliders (optional, could reset to defaults)
                document.getElementById('modalMaxWidthRange').value = 800;
                document.getElementById('modalQualityRange').value = 0.8;
                updateModalRangeValue('modalMaxWidthRange', 'modalMaxWidthValue');
                updateModalRangeValue('modalQualityRange', 'modalQualityValue', true);
                drawPreviewImage(); // Draw initial preview
            };
            originalImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });

    function openImageModal() {
        document.getElementById('imageModalOverlay').style.display = 'flex';
    }

    function closeImageModal() {
        document.getElementById('imageModalOverlay').style.display = 'none';
        // Clear original image source and file input to reset
        originalImage.src = '';
        document.getElementById('fileInput').value = '';
    }

    function drawPreviewImage() {
        if (!originalImage.src || !modalCanvas || !modalCtx) {
            return;
        }

        const MAX_WIDTH = parseInt(document.getElementById('modalMaxWidthRange').value, 10);
        // Quality is not used for drawing, only for toDataURL, but good to get it.
        // const QUALITY = parseFloat(document.getElementById('modalQualityRange').value);

        let width = originalImage.width;
        let height = originalImage.height;

        // Calculate new dimensions while maintaining aspect ratio for display
        if (width > height) {
            if (width > MAX_WIDTH) {
                height *= MAX_WIDTH / width;
                width = MAX_WIDTH;
            }
        } else {
            // Apply max height if portrait and taller than a reasonable limit
            const MODAL_MAX_HEIGHT_PREVIEW = 400; // Limit height for modal display
            if (height > MODAL_MAX_HEIGHT_PREVIEW) {
                width *= MODAL_MAX_HEIGHT_PREVIEW / height;
                height = MODAL_MAX_HEIGHT_PREVIEW;
            }
            if (width > MAX_WIDTH) { // Re-check width after height adjustment if it exceeds max_width
                height *= MAX_WIDTH / width;
                width = MAX_WIDTH;
            }
        }


        // Set canvas dimensions
        modalCanvas.width = width;
        modalCanvas.height = height;

        // Clear canvas and draw image
        modalCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
        modalCtx.drawImage(originalImage, 0, 0, width, height);
    }

    function applyImageSettings() {
        if (!originalImage.src || !modalCanvas || !modalCtx) {
            alert('No image selected or loaded for processing.');
            closeImageModal();
            return;
        }

        const MAX_WIDTH_FINAL = parseInt(document.getElementById('modalMaxWidthRange').value, 10);
        const QUALITY_FINAL = parseFloat(document.getElementById('modalQualityRange').value);

        let finalWidth = originalImage.width;
        let finalHeight = originalImage.height;

        // Calculate final dimensions for encoding
        if (finalWidth > finalHeight) {
            if (finalWidth > MAX_WIDTH_FINAL) {
                finalHeight *= MAX_WIDTH_FINAL / finalWidth;
                finalWidth = MAX_WIDTH_FINAL;
            }
        } else {
            // Also ensure it's not excessively tall
            const ABSOLUTE_MAX_HEIGHT_ENCODE = 1500; // A higher limit for actual encoding
            if (finalHeight > ABSOLUTE_MAX_HEIGHT_ENCODE) {
                finalWidth *= ABSOLUTE_MAX_HEIGHT_ENCODE / finalHeight;
                finalHeight = ABSOLUTE_MAX_HEIGHT_ENCODE;
            }
            if (finalWidth > MAX_WIDTH_FINAL) { // Re-check width after height adjustment
                finalHeight *= MAX_WIDTH_FINAL / finalWidth;
                finalWidth = MAX_WIDTH_FINAL;
            }
        }

        // Create a temporary canvas for the final encoding
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = finalWidth;
        tempCanvas.height = finalHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(originalImage, 0, 0, finalWidth, finalHeight);

        const base64String = tempCanvas.toDataURL('image/jpeg', QUALITY_FINAL);

        currentEncodedImage = base64String;
        document.getElementById('imageOutput').value = base64String;
        document.getElementById('imgPreview').src = base64String;
        document.getElementById('imgPreview').style.display = 'block';

        closeImageModal();
        alert('Image encoded with specified settings!');
    }

    // This function will be called if the user clicks the main "Encode" button
    // which should now encode the *currently displayed* image in imgPreview/imageOutput
    // if a file wasn't picked via the modal flow.
    function encodeImageFromCurrentInput() {
        const outputString = document.getElementById('imageOutput').value;
        if (outputString && outputString.startsWith("data:image")) {
            alert('Image is already encoded based on your last selection or paste.');
            // You could optionally re-encode with current (hidden) modal settings if desired
            // But for simplicity, we assume "Encode" means to use the existing output
        } else {
            alert('Please choose an image via "Choose Image" to apply settings, or paste a Base64 string to decode.');
        }
    }


    function decodeImageString() {
      const base64String = document.getElementById('imageOutput').value;
      if (!base64String) {
        alert('Please paste or encode an image Base64 string first to decode.');
        return;
      }

      if (base64String.startsWith("data:image/")) {
        document.getElementById('imgPreview').src = base64String;
        document.getElementById('imgPreview').style.display = 'block';
        alert('Image decoded and displayed in preview.');
      } else {
        alert("Pasted content is not a valid image Base64 string (missing 'data:image/' prefix).");
        document.getElementById('imgPreview').style.display = 'none';
        document.getElementById('imgPreview').src = '';
      }
    }

    function pasteImage() {
      navigator.clipboard.readText().then(text => {
        document.getElementById('imageOutput').value = text;
        currentEncodedImage = text; // Store for potential decode/copy

        if (text.startsWith("data:image")) {
          document.getElementById('imgPreview').src = text;
          document.getElementById('imgPreview').style.display = 'block';
        } else {
          alert("Pasted content is not a valid image base64. Ensure it starts with 'data:image/'.");
          document.getElementById('imgPreview').style.display = 'none';
          document.getElementById('imgPreview').src = '';
        }
      }).catch(err => {
        alert("Clipboard access denied. Please ensure your browser grants permission.");
        console.error("Clipboard paste error:", err);
      });
    }

    function copyText(id) {
      const textArea = document.getElementById(id);
      const textToCopy = (id === 'imageOutput' && currentEncodedImage) ? currentEncodedImage : textArea.value;

      if (!textToCopy) {
        alert('Nothing to copy!');
        return;
      }

      navigator.clipboard.writeText(textToCopy)
        .then(() => {
          alert('Copied to clipboard!');
        })
        .catch(err => {
          textArea.select();
          document.execCommand("copy");
          alert('Copied to clipboard (fallback)!');
          console.warn("Clipboard writeText failed, used fallback:", err);
        });
    }

    function updateModalRangeValue(rangeId, valueId, isPercentage = false) {
        const range = document.getElementById(rangeId);
        const valueSpan = document.getElementById(valueId);
        if (isPercentage) {
            valueSpan.textContent = Math.round(parseFloat(range.value) * 100) + '%';
        } else {
            valueSpan.textContent = range.value + 'px';
        }
    }
  </script>
</body>
</html>
